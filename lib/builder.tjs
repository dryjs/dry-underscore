
exports.mixin = function(_){

    function builder(options){
        options = options || {};

        this._clean = options.clean || false;
        this._cache = this.emptyCache();
        if(options.root){ this.paths.root(options.root()); }
    }

    builder.prototype.clean = _.r("_clean");

    builder.prototype.cache = function(key){
        if(key !== undefined){
            return(this._cache.results[key]);
        }else{
            return(this._cache);
        }
    };

    builder.prototype.emptyCache = function(){
        return({ 
            last: 0,
            results: {}
        });
    };

    builder.prototype.last = function(){
        return(this._cache["last"]);
    };

    builder.prototype.paths = (function(){

        var paths = _.path.make();

        paths.cache = paths.fun(paths.root, ".build");

        return(paths);

    })();

    builder.prototype.load = function(callback){
        if(this._clean){
            this._cache = this.emptyCache();
            return callback(null);
        }

        await{ _.fs.readFile(this.paths.cache(), defer(var err, data)); }
        if(err){
            if(_.ecode.noEnt(err)){ 
                this._cache = this.emptyCache();
                return callback(null);
            }else{ 
                err.path = this.paths.cache();
                return callback(err);
            }
        }

        try{ this._cache = _.parse(data); }
        catch(e){ 
            e.path = this.paths.cache();
            return callback(e);
        }

        return callback(null);
    };

    builder.prototype.finished = function(){
        this._cache["last"] = _.timestamp();
    };

    builder.prototype.save = function(callback){
        await{ _.fs.writeFile(this.paths.cache(), _.stringify(cache), callback); }
    };

    builder.prototype.build = function(path, buildFunction, callback){
        var file = {
            created: false,
            removed: false,
            exists: false,
            dirty: false,
            path: path
        };

        await{ _.fs.estat(path, _.plumb(defer(var exists, stat), callback)); }

        file.exists = exists;

        if(!file.exists){
            if(this.cache(path)){
                file.removed = true;
                file.dirty = true;
                delete this.cache().path;
            }
            return callback(null, file);
        }

        file.mtime = stat.mtime.getTime();

        if(!this.cache(path)){ file.created = true; }

        file.dirty = file.created || file.removed || file.mtime <= this.last();

        if(!file.dirty){
            return callback(null, file, this.cache(path));
        }else{
            await{ _.fs.readFile(path, _.plumb(defer(var data), callback)); }
            await{ buildFunction(file, data, _.plumb(defer(var result), callback)); }

            callback(null, file, results);
        }
    };


    return(function(options){ return(new builder(options)); });
};




