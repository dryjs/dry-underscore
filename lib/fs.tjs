"use strict";

var nativeFs = require('fs');
var minimatch = require('minimatch');

function lib(_){

var fs = {};

fs.path = require('path');

fs.path.prepend = function(path, arr){
    if(_.isArray(arr)){
        return(_.map(arr, function(endOfPath){ return(fs.path.join(path, endOfPath)); }));
    }else{
        return(fs.path.join(path, arr));
    }
};

fs.path.changeFile = function(path, newName){
    return(fs.path.join(fs.path.dirname(path), newName));
};

fs.path.changeExtension = function(path, extension){
    var fileName = fs.path.basename(path);
    var fsSplit = fileName.split(".");

    if(fsSplit.length > 1){ fsSplit.pop(); }
    fsSplit.push(extension);
    
    return(fs.path.join(fs.path.dirname(path), fsSplit.join(".")));
};

fs.path.hideFile = function(path){
    return(fs.path.join(fs.path.dirname(path), "." + fs.path.basename(path)));
};

fs.path.isHidden = function(path){ return(fs.path.basename(path)[0] === "."); };

fs.path.addSlash = function(path){
    if(path.length > 0 && path[path.length-1] !== '/'){ return(path + '/'); }
    else{ return(path); }   
};

fs.path.removeSlash = function(path){
    if(path.length > 0 && path[path.length-1] === '/'){ return(path.substr(0, path.length-1)); }
    else{ return(path); }   
};

fs.path.pop = function(path){
    var pathSplit = path.split('/');
    if(pathSplit.pop() === ""){ pathSplit.pop(); }
    return(pathSplit.join("/"));
};


fs.glob = {};
fs.glob.matchFile = function(path, glob, options){
    if(_.isBoolean(options)){ options = { dot : options }; }
    return(minimatch(path, glob, _.extend({ matchBase: true, nonegate: true}, options)));
};

fs.glob.matchPath = function(path, glob, options){
    if(_.isBoolean(options)){ options = { dot : options }; }
    return(minimatch(path, glob, _.extend({nonegate: true}, options)));
};

fs.error = {};
fs.error.isNoEnt = function(e){ return(e.code === "ENOENT"); }
fs.error.isNotDir = function(e){ return(e.code === "ENOTDIR"); }

fs.moveFile = nativeFs.rename;
fs.moveFile.sync = nativeFs.renameSync;

fs.moveFiles = function(filePaths, callback){
    _.each.async(filePaths, function(pathObj, i, next, finish){
        await { fs.moveFile(pathObj.src, pathObj.dest, defer(var err)); }
        if(err){ callback(err); }
        else{ next(); }
    }, callback);
};

// function(filePath, text, callback){
fs.writeFile = nativeFs.writeFile;
fs.writeFile.sync = nativeFs.writeFileSync;

fs.readFile = function(filePath, callback){
    nativeFs.readFile(filePath, 'utf8', callback);
};

fs.readFile.sync = function(filePath){
    return(nativeFs.readFileSync(filePath, 'utf8'));
};


fs.readJsonFile = function(path, callback){
    fs.readFile(path, _.plumber(function(text){
        try{ callback(null, _.parse(text)); }
        catch(e){ callback(e, null); }
    }, callback));
};
 
fs.evalFile = function(path, callback){
    fs.readFile(path, _.plumber(function(data){
        try{ callback(null, eval("(" + data + ")")); }
        catch(e){ callback(_.error("FileParseError", "There was a problem parsing a file: " + path, e)); }
    }, callback));
};

fs.evalFile.sync = function(path){
    var data = fs.readFile.sync(path);

    try{ return(eval("(" + data + ")")); }
    catch(e){ throw(_.error("FileParseError", "There was a problem parsing a file: " + path, e)); }
 
    return(evalData);                
};

fs.renderFile = function(path, hash, callback){
    fs.readFile(path, _.plumber(function(text){
        try{ callback(null, _.render(text, hash)); }
        catch(e){ callback(_.error("RenderError", "There was a problem rendering a file: " + path, e)); }
    }, callback));
};

fs.renderFolder = function(src, dest, hash, ignoreFile, processFileName, callback){
    src = fs.path.addSlash(src);
    dest = fs.path.addSlash(dest);

    await {
        fs.files(src, _.plumb(defer(var files), callback));
        fs.makeTree(dest, _.plumb(defer(), callback));
    } 

    _.each.async(files, function(file, index, next){
        var newFileName = fs.path.basename(file);

        if(ignoreFile(newFileName)){ return next(); }

        var mu = _.regex("\.mu$");
        var hb = _.regex("\.hb$");

        if(file.match(mu) || file.match(hb)){

            var templatePath = file.replace(mu, "");
            templatePath = file.replace(hb, "");
            newFileName = fs.path.basename(templatePath);

            // render file
            newFileName = processFileName(newFileName);
            await{ fs.renderFile(templatePath, hash, _.plumb(defer(var str), callback)); }
            await{ fs.writeFile(dest + newFileName, str, _.plumb(defer(), callback)); }
            next();

        }else{
            
            // copy file
            newFileName = fs.path.basename(file);
            await{ fs.readFile(file, _.plumb(defer(var str), callback)); }
            await{ fs.writeFile(dest + newFileName, str, _.plumb(defer())); }
            next();
        }

    }, function(){
        await{ fs.directories(src, _.plumb(defer(var dirs), callback)); }

        _.each.async(dirs, function(dir, index, next){

            await{ fs.makeTree(dest + dir, _.plumb(defer())); }
            await{ fs.renderFolder(src + dir, dest + dir, hash, ignoreFile, processFileName, _.plumb(defer(), callback)); }
            next();

        }, callback);
    });
};

fs.isDirectoryEmpty = function(path, ignore, callback){
    if(_.isFunction(ignore)){
       callback = ignore;
       ignore = [];
    }

    await{ fs.readDir(path, _.plumb(defer(var contents), callback)); }

    for(var i = 0; i < contents.length; i++){
        if(!_.exists(ignore, contents[i], true)){
            return callback(null, false);
        }
    }

    return callback(null, true);

};

fs.isDirectoryEmpty.sync = function(path, ignore){
    if(ignore === undefined){ ignore = []; }

    var contents = fs.readDir.sync(path);
    for(var i = 0; i < contents.length; i++){
        if(!_.exists(ignore, contents[i], true)){
            return(false);
        }
    }
    return(true);
};

fs.directoryContains = function(path, name, caseSensitive, callback){
    if(_.isFunction(caseSensitive)){
	callback = caseSensitive;
	caseSensitive = false;
    }
    
    await{ fs.readDir(path, _.plumb(defer(var contents), callback)); }
    for(var i = 0; i < contents.length; i++){
        if(caseSensitive){
            if(contents[i] === name){ return callback(null, true); }
        }else{
            if(_.lc(contents[i]) === _.lc(name)){ return callback(null, true); }
        }
    }

    return callback(null, false);
};

fs.directoryContains.sync = function(path, name, caseSensitive){
    
    var contents = fs.readDir.sync(path);
    for(var i = 0; i < contents.length; i++){
        if(caseSensitive){
            if(contents[i] === name){ return(true); }
        }else{
            if(_.lc(contents[i]) === _.lc(name)){ return(true); }
        }
    }

    return(false);
};

fs.findFileInParents = function(childDirectory, fileName, callback){
    
    var currentPath = fs.path.addSlash(childDirectory);
    
    if(currentPath === ""){ return callback(null, ""); }

    await{ fs.directoryContains(currentPath, fileName, _.plumb(defer(var doesExist), callback)); }

    if(doesExist){ return callback(null, currentPath); }

    currentPath = fs.path.pop(currentPath);

    fs.findFileInParents(currentPath, fileName, callback);
    
};

fs.findFileInParents.sync = function(childDirectory, fileName){
    
    var currentPath = fs.path.addSlash(childDirectory);

    while(!fs.directoryContains.sync(currentPath, fileName)){
    
        currentPath = fs.path.pop(currentPath);
        
        if(currentPath === ""){ return(""); }
    }

    return(currentPath);
};


fs.modificationTime = function(filePath, callback){
    nativeFs.stat(filePath, function(err, stats){
        if(err){ callback(err); }
        else{ callback(null, stats.mtime.getTime()); }
    });
};

fs.estat = function(path, callback){
    await{ nativeFs.stat(path, defer(var err, stats)); }

    if(err){
        if(fs.error.isNoEnt(err)){ return callback(null, false); }
        else{ return callback(err); }
    }else if(stats){
        callback(null, true, stats);
    }
};

fs.exists = fs.estat;

fs.exists.sync = function(path){
    try { return(nativeFs.statSync(path) !== null); }
    catch(e){ 
        if(fs.error.isNoEnt(e)){ return(false); }
        else{ throw(e); }
    }
};

fs.fileExists = function (path, callback) {
    await{ fs.estat(path, _.plumb(defer(var exists, stats), callback)); }
    return callback(null, exists && !stats.isDirectory());
};
    
fs.fileExists.sync = function (path) {
    try { return(!(nativeFs.statSync(path).isDirectory())); }
    catch(e){ 
        if(fs.error.isNoEnt(e)){ return(false); }
        else{ throw(e); }
    }
};

fs.directoryExists = function (path, callback) {
    await{ fs.estat(path, _.plumb(defer(var exists, stats), callback)); }
    return callback(null, exists && stats.isDirectory());
};
    
fs.directoryExists.sync = function (path) {
    try { return((nativeFs.statSync(path).isDirectory())); }
    catch(e){ 
        if(fs.error.isNoEnt(e)){ return(false); }
        else{ throw(e); }
    }
};

fs.isFile = fs.fileExists;
fs.isFile.sync = fs.fileExists.sync;

fs.isDirectory = fs.directoryExists;
fs.isDirectory.sync = fs.directoryExists.sync;

fs.directories = function(path, callback, fullPath){ fs.readDir(path, { directories: true, fullPath: (fullPath !== undefined ? fullPath : true) }, callback); };
fs.directories.sync = function(path, fullPath){ return(fs.readDir.sync(path, { directories: true, fullPath: (fullPath !== undefined ? fullPath : true) })); };

fs.files = function(path, callback, fullPath){ fs.readDir(path, { files: true, fullPath: (fullPath !== undefined ? fullPath : true) }, callback); };
fs.files.sync = function(path, fullPath){ return fs.readDir.sync(path, { files: true, fullPath: (fullPath !== undefined ? fullPath : true) }); };

fs.readDir = function(path, options, callback){
    if(_.isFunction(options)){
        callback = options;
        options = { files: true, directories : true, fullPath: false };
    } 

    await{ nativeFs.readdir(path, _.plumb(defer(var contents), callback)); }

    var filterFunction = null;

    if(!options.directories && options.files === true){
        filterFunction = fs.isFile;
    }else if(!options.files && options.directories === true){
        filterFunction = fs.isDirectory;
    }

    if(filterFunction){
        await{
            _.filter.async(contents, function(entryName, i, next){
                await{ filterFunction(fs.path.prepend(path, entryName), _.plumb(defer(var include), callback)); }
                next(include);
            }, defer(contents));
        }

    }

    if(options.fullPath){ callback(null, fs.path.prepend(path, contents)); }
    else{ return callback(null, contents); }
};



fs.readDir.sync = function(path, options){

    options = options || { files: true, directories : true, fullPath: false };

    var contents = nativeFs.readdirSync(path);

    var filterFunction = null;

    if(!options.directories && options.files === true){
        filterFunction = fs.isFile.sync;
    }else if(!options.files && options.directories === true){
        filterFunction = fs.isDirectory.sync;
    }

    if(filterFunction){
        contents = _.filter(contents, function(entryName){
            return(filterFunction(fs.path.prepend(path, entryName)));
        });
    }

    if(options.fullPath){ return(fs.path.prepend(path, contents)); }
    else{ return(contents); }
};

fs.walk = function(path, onFile, onDir, callback){
    await{ fs.files(path, _.plumb(defer(var files), callback)); }

    _.each.async(files, function(file, index, next){
        onFile(fs.path.basename(file), file, next);
    }, function(){
        await{ fs.directories(path, _.plumb(defer(var dirs), callback)); }
        _.each.async(dirs, function(dir, index, next){
            onDir(fs.path.basename(dir), dir, function(recurse){
                if(recurse !== false){
                    fs.walk(dir, onFile, onDir, function(err){
                        if(err){ return callback(err); }
                        else{ next(); }
                    });
                }else{ next(); }
            });
        }, function(){ if(callback){ callback(); } });
    });
};

fs.walk.sync = function(path, onFile, onDir){
    var files = fs.files.sync(path);
    _.each(files, function(file){
        onFile(fs.path.basename(file), file);
    });

    var dirs = fs.directories.sync(path);
    _.each(dirs, function(dir){
        if(onDir(fs.path.basename(dir), dir) !== false){
            fs.walk.sync(dir, onFile, onDir);
        }
    });
};

fs.find = function(path, options, callback){
    if(_.isFunction(options) && !_.isFunction(callback)){
        callback = options;
        options = {};
    }

    if(_.isString(options) || _.isFunction(options)){
        options = { pattern: options };
    }
    
    if(!options){ options = {}; }

    var include = function (fileName, filePath){
        var shouldInclude = true;
        if(_.isFunction(options.pattern)){
            shouldInclude = options.pattern(fileName, filePath);
        }else if(_.isString(options.pattern)){
            shouldInclude = fs.glob.matchFile(fileName, options.pattern);
        }
        return(shouldInclude);
    }
 
    var found = [];

    fs.walk(path, function onFile(fileName, filePath, next){
        if(include(fileName, filePath)){ found.push(filePath); }
        next();
    }, function onDir(dirName, dirPath, next){ 
        if(options.prune){ next(!options.prune(dirName, dirPath)); }
        else{ next(); }
    }, function(err){ 
        if(err){ callback(err); }
        else{ callback(null, found); }
    }); 
};

fs.find.sync = function(path, options){

    if(_.isString(options) || _.isFunction(options)){
        options = { pattern: options };
    }
    
    if(!options){ options = {}; }

    var include = function (fileName, filePath){
        var shouldInclude = true;
        if(_.isFunction(options.pattern)){
            shouldInclude = options.pattern(fileName, filePath);
        }else if(_.isString(options.pattern)){
            shouldInclude = fs.glob.matchFile(fileName, options.pattern);
        }
        return(shouldInclude);
    }
 
    var found = [];

    fs.walk.sync(path, function onFile(fileName, filePath){
        if(include(fileName, filePath)){ found.push(filePath); }
    }, function onDir(dirName, dirPath){
        if(options.prune){ return(!options.prune(dirName, dirPath)); }
    }); 

    return(found);
};

fs.makeTree = function(path, mode, callback){
    
    if(_.isFunction(mode)){
        callback = mode;
        mode = null;
    }
    
    mode = mode || '755';
    
    path = fs.path.addSlash(path);
    path = fs.path.normalize(path);
    
    await{ fs.exists(path, _.plumb(defer(var exists), callback)); }

    if(exists){ return callback(); }

    var pathSplit = path.split("/");

    if(pathSplit.pop() === ""){ pathSplit.pop();}

    fs.makeTree(fs.path.addSlash(pathSplit.join("/")), mode, function(err){
        if(err){ callback(err); }
        else{ nativeFs.mkdir(path, mode, callback); }
    });
};

fs.makeTree.sync = function(path, mode){
    mode = mode || '755';
    
    path = fs.path.addSlash(path);
    path = fs.path.normalize(path);

    if(!fs.exists.sync(path)){
        var pathSplit = path.split("/");
    
        if(pathSplit.pop() === ""){ pathSplit.pop();}
    
        fs.makeTree.sync(fs.path.addSlash(pathSplit.join("/")), mode);
        
        nativeFs.mkdirSync(path, mode);
    }
};

fs.deleteFile = nativeFs.unlink;
fs.deleteFile.sync = nativeFs.unlinkSync;

fs.removeTree = function(path, callback){
    path = fs.path.addSlash(path);
        
    await{ fs.directories(path, _.plumb(defer(var folders), callback)); }

    _.each.async(folders, function(folder, index, next){
    
        await{ nativeFs.lstat(folder, _.plumb(defer(var stat), callback)); }

        if(stat.isSymbolicLink()){
            await{ nativeFs.unlink(folder, _.plumb(defer(), callback)); }
        }else{
            await{ fs.removeTree(folder, _.plumb(defer(), callback)); }
        }
        
        next();

    }, function(){

        await{ fs.files(path, _.plumb(defer(var files), callback), true); }

        _.each.async(files, function(file, index, next){
            await{ nativeFs.unlink(file, _.plumb(defer(), callback)); }
            next(); 
        }, function(){
            await{ nativeFs.rmdir(path, _.plumb(defer(), callback)); }
            callback();
        });
    });
};

fs.removeTree.sync = function(path){

    if(!fs.exists.sync(path)){ return; }
    
    var files = fs.readDir.sync(path);
    
    for(var i = 0; i < files.length; i++){
        var currentPath = fs.path.join(path, files[i]);
        
        var stat = nativeFs.lstatSync(currentPath);

        if(stat.isSymbolicLink() || !stat.isDirectory()){
            nativeFs.unlinkSync(currentPath);
        }else{
            fs.removeTree.sync(currentPath);
        }
    }

    nativeFs.rmdirSync(path);
};
 
/*
fs.copyFileSync = function(srcFile, destFile){
    var BUF_LENGTH, buff, bytesRead, fdr, fdw, pos;
    BUF_LENGTH = 64 * 1024;
    buff = new Buffer(BUF_LENGTH);
    fdr = nativeFs.openSync(srcFile, 'r');
    fdw = nativeFs.openSync(destFile, 'w');
    bytesRead = 1;
    pos = 0;
    while (bytesRead > 0) {
        bytesRead = nativeFs.readSync(fdr, buff, 0, BUF_LENGTH, pos);
        nativeFs.writeSync(fdw, buff, 0, bytesRead);
        pos += bytesRead;
    }
    nativeFs.closeSync(fdr);
    return nativeFs.closeSync(fdw);
};

fs.getFolderContentInfo = function getFolderContentInfo(path, recursive, callback, filter, processInfo){
    if(typeof(recursive) === 'function'){
        callback = recursive;
        recursive = false;
    }

    if(!filter){ filter = function(){return(true);}; }
    if(!processInfo){ processInfo = function(){}; }
    
    var contents = [];
    
    await { nativeFs.readdir(path, defer(var err, files)); }
    if(err){ throw(err); }
    
    await {
        for(var i = 0; i < files.length; i++){
            (function(file, cb){
                if(filter(file)){
                    await { nativeFs.stat(fs.path.join(path, file), defer(var err, stats));}
                    if(err){throw(err);}
                    var info = "";
                    if(recursive && stats.isDirectory() ){
                        await{ getFolderContentInfo(fs.path.join(path, file), recursive, defer(var recursiveInfo), filter, processInfo); }
                        info = { FileName : file, FilePath : fs.path.join(path, file), IsDirectory : stats.isDirectory(), Contents: recursiveInfo, MTime : stats.mtime, stats: stats};
                    }else{
                        info = { FileName : file, FilePath : fs.path.join(path, file), IsDirectory : stats.isDirectory(), MTime : stats.mtime, stats: stats};
                    }
                    processInfo(info);
                    contents.push(info);
                }

                cb();
            })(files[i], defer());
        }
    }
    
    callback(contents);
};
*/

/*
fs.testFilterAsyncTame = function(){

    var called = 0;

    var a = [1, 2, 3, 4, 5, 6];

    await { 
        _.filter.async(a, function(val, i, next){
            await{ _.nextTick(defer()); }
            next(val < 4); 
        }, defer(var result)); 
    }

    _.test.eq(result, [1, 2, 3]);

    _.p("TEST COMPLETE");
};
*/

return(fs);

}

exports.fs = lib;
