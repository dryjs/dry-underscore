"use strict";

var nativeFs = require('fs');

function lib(_){

var fs = {};

fs.moveFile = nativeFs.rename;
fs.moveFile.sync = nativeFs.renameSync;

fs.moveFiles = function(filePaths, callback){
    _.each.async(filePaths, function(pathObj, i, next, finish){
        await { fs.moveFile(pathObj.src, pathObj.dest, defer(var err)); }
        if(err){ callback(err); }
        else{ next(); }
    }, callback);
};

// function(filePath, text, callback){
fs.writeFile = nativeFs.writeFile;
fs.writeFile.sync = nativeFs.writeFileSync;

fs.readFile = function(filePath, callback){
    nativeFs.readFile(filePath, 'utf8', callback);
};

fs.readFile.sync = function(filePath){
    return(nativeFs.readFileSync(filePath, 'utf8'));
};


fs.readJsonFile = function(path, callback){
    fs.readFile(path, _.plumb(function(text){
        try{ var result = _.parse(text); }
        catch(e){ return callback(_.error("FileParseError", "There was a problem parsing a file: " + path, e)); }

        return callback(null, result);
    }, callback));
};
 
fs.evalFile = function(path, callback){
    fs.readFile(path, _.plumb(function(data){
        try{ var result = eval("(" + data + ")"); }
        catch(e){ return callback(_.error("FileParseError", "There was a problem parsing a file: " + path, e)); }

        return callback(null, result); 
    }, callback));
};

fs.evalFile.sync = function(path){
    var data = fs.readFile.sync(path);

    try{ return(eval("(" + data + ")")); }
    catch(e){ throw(_.error("FileParseError", "There was a problem parsing a file: " + path, e)); }
 
    return(evalData);                
};

fs.renderFile = function(path, hash, callback){
    fs.readFile(path, _.plumb(function(text){
        try{ var result = _.render(text, hash); }
        catch(e){ return callback(_.error("RenderError", "There was a problem rendering a file: " + path, e)); }

        return callback(null, result);
    }, callback));
};

fs.renderFolder = function(src, dest, hash, ignoreFile, processFileName, callback){
    src = _.path.slash(src);
    dest = _.path.slash(dest);

    await {
        fs.files(src, _.plumb(defer(var files), callback));
        fs.mkdir(dest, _.plumb(defer(), callback));
    } 

    _.each.async(files, function(file, index, next){
        var newFileName = _.path.base(file);

        if(ignoreFile(newFileName)){ return next(); }

        var mu = _.regex("\.mu$");
        var hb = _.regex("\.hb$");

        if(file.match(mu) || file.match(hb)){

            var templatePath = file.replace(mu, "");
            templatePath = file.replace(hb, "");
            newFileName = _.path.base(templatePath);

            // render file
            newFileName = processFileName(newFileName);
            await{ fs.renderFile(templatePath, hash, _.plumb(defer(var str), callback)); }
            await{ fs.writeFile(dest + newFileName, str, _.plumb(defer(), callback)); }
            next();

        }else{
            
            // copy file
            newFileName = _.path.base(file);
            await{ fs.readFile(file, _.plumb(defer(var str), callback)); }
            await{ fs.writeFile(dest + newFileName, str, _.plumb(defer())); }
            next();
        }

    }, function(){
        await{ fs.directories(src, _.plumb(defer(var dirs), callback)); }

        _.each.async(dirs, function(dir, index, next){

            await{ fs.mkdir(dest + dir, _.plumb(defer())); }
            await{ fs.renderFolder(src + dir, dest + dir, hash, ignoreFile, processFileName, _.plumb(defer(), callback)); }
            next();

        }, callback);
    });
};

fs.isDirectoryEmpty = function(path, ignore, callback){
    if(_.isFunction(ignore)){
       callback = ignore;
       ignore = [];
    }

    await{ fs.readDir(path, _.plumb(defer(var contents), callback)); }

    for(var i = 0; i < contents.length; i++){
        if(!_.exists(ignore, contents[i], true)){
            return callback(null, false);
        }
    }

    return callback(null, true);

};

fs.isDirectoryEmpty.sync = function(path, ignore){
    if(ignore === undefined){ ignore = []; }

    var contents = fs.readDir.sync(path);
    for(var i = 0; i < contents.length; i++){
        if(!_.exists(ignore, contents[i], true)){
            return(false);
        }
    }
    return(true);
};

fs.directoryContains = function(path, name, caseSensitive, callback){
    if(_.isFunction(caseSensitive)){
	callback = caseSensitive;
	caseSensitive = false;
    }
    
    await{ fs.readDir(path, _.plumb(defer(var contents), callback)); }
    for(var i = 0; i < contents.length; i++){
        if(caseSensitive){
            if(contents[i] === name){ return callback(null, true); }
        }else{
            if(_.lc(contents[i]) === _.lc(name)){ return callback(null, true); }
        }
    }

    return callback(null, false);
};

fs.directoryContains.sync = function(path, name, caseSensitive){
    
    var contents = fs.readDir.sync(path);
    for(var i = 0; i < contents.length; i++){
        if(caseSensitive){
            if(contents[i] === name){ return(true); }
        }else{
            if(_.lc(contents[i]) === _.lc(name)){ return(true); }
        }
    }

    return(false);
};

fs.findInParents = function(childDirectory, fileName, callback){
    
    var currentPath = _.path.slash(childDirectory);
    
    if(currentPath === ""){ return callback(null, ""); }

    await{ fs.directoryContains(currentPath, fileName, _.plumb(defer(var doesExist), callback)); }

    if(doesExist){ return callback(null, currentPath); }

    currentPath = _.path.pop(currentPath);

    fs.findInParents(currentPath, fileName, callback);
    
};

fs.findInParents.sync = function(childDirectory, fileName){
    
    var currentPath = _.path.slash(childDirectory);

    while(!fs.directoryContains.sync(currentPath, fileName)){
    
        currentPath = _.path.pop(currentPath);
        
        if(currentPath === ""){ return(""); }
    }

    return(currentPath);
};


fs.modificationTime = function(filePath, callback){
    fs.stat(filePath, function(err, stats){
        if(err){ callback(err); }
        else{ callback(null, stats.mtime.getTime()); }
    });
};

fs.stat = nativeFs.stat;

fs.estat = function(path, callback){
    await{ fs.stat(path, defer(var err, stats)); }

    if(err){
        if(_.error.noent(err)){ return callback(null, false); }
        else{ return callback(err); }
    }else if(stats){
        callback(null, true, stats);
    }
};

fs.exists = fs.estat;

fs.exists.sync = function(path){
    try { return(nativeFs.statSync(path) !== null); }
    catch(e){ 
        if(_.error.noent(e)){ return(false); }
        else{ throw(e); }
    }
};

fs.fileExists = function (path, callback) {
    await{ fs.estat(path, _.plumb(defer(var exists, stats), callback)); }
    return callback(null, exists && !stats.isDirectory());
};
    
fs.fileExists.sync = function (path) {
    try { return(!(nativeFs.statSync(path).isDirectory())); }
    catch(e){ 
        if(_.error.noent(e)){ return(false); }
        else{ throw(e); }
    }
};

fs.directoryExists = function (path, callback) {
    await{ fs.estat(path, _.plumb(defer(var exists, stats), callback)); }
    return callback(null, exists && stats.isDirectory());
};
    
fs.directoryExists.sync = function (path) {
    try { return((nativeFs.statSync(path).isDirectory())); }
    catch(e){ 
        if(_.error.noent(e)){ return(false); }
        else{ throw(e); }
    }
};

fs.isFile = fs.fileExists;
fs.isFile.sync = fs.fileExists.sync;

fs.isDirectory = fs.directoryExists;
fs.isDirectory.sync = fs.directoryExists.sync;

fs.directories = function(path, callback, fullPath){ fs.readDir(path, { directories: true, fullPath: (fullPath !== undefined ? fullPath : true) }, callback); };
fs.directories.sync = function(path, fullPath){ return(fs.readDir.sync(path, { directories: true, fullPath: (fullPath !== undefined ? fullPath : true) })); };

fs.files = function(path, callback, fullPath){ fs.readDir(path, { files: true, fullPath: (fullPath !== undefined ? fullPath : true) }, callback); };
fs.files.sync = function(path, fullPath){ return fs.readDir.sync(path, { files: true, fullPath: (fullPath !== undefined ? fullPath : true) }); };

fs.readDir = function(path, options, callback){
    if(_.isFunction(options)){
        callback = options;
        options = { files: true, directories : true, fullPath: false };
    } 

    await{ nativeFs.readdir(path, _.plumb(defer(var contents), callback)); }

    var filterFunction = null;

    if(!options.directories && options.files === true){
        filterFunction = fs.isFile;
    }else if(!options.files && options.directories === true){
        filterFunction = fs.isDirectory;
    }

    if(filterFunction){
        await{
            _.filter.async(contents, function(entryName, i, next){
                await{ filterFunction(_.path.prepend(path, entryName), _.plumb(defer(var include), callback)); }
                next(include);
            }, defer(contents));
        }

    }

    if(options.fullPath){ callback(null, _.path.prepend(path, contents)); }
    else{ return callback(null, contents); }
};



fs.readDir.sync = function(path, options){

    options = options || { files: true, directories : true, fullPath: false };

    var contents = nativeFs.readdirSync(path);

    var filterFunction = null;

    if(!options.directories && options.files === true){
        filterFunction = fs.isFile.sync;
    }else if(!options.files && options.directories === true){
        filterFunction = fs.isDirectory.sync;
    }

    if(filterFunction){
        contents = _.filter(contents, function(entryName){
            return(filterFunction(_.path.prepend(path, entryName)));
        });
    }

    if(options.fullPath){ return(_.path.prepend(path, contents)); }
    else{ return(contents); }
};

fs.walk = function(path, onFile, onDir, callback){
    await{ fs.files(path, _.plumb(defer(var files), callback)); }

    _.each.async(files, function(file, index, next){
        onFile(_.path.base(file), file, next);
    }, function(){
        await{ fs.directories(path, _.plumb(defer(var dirs), callback)); }
        _.each.async(dirs, function(dir, index, next){
            onDir(_.path.base(dir), dir, function(recurse){
                if(recurse !== false){
                    fs.walk(dir, onFile, onDir, function(err){
                        if(err){ return callback(err); }
                        else{ next(); }
                    });
                }else{ next(); }
            });
        }, function(){ if(callback){ callback(); } });
    });
};

fs.walk.sync = function(path, onFile, onDir){
    var files = fs.files.sync(path);
    _.each(files, function(file){
        onFile(_.path.base(file), file);
    });

    var dirs = fs.directories.sync(path);
    _.each(dirs, function(dir){
        if(onDir(_.path.base(dir), dir) !== false){
            fs.walk.sync(dir, onFile, onDir);
        }
    });
};

fs.find = function(path, options, callback){
    if(_.isFunction(options) && !_.isFunction(callback)){
        callback = options;
        options = {};
    }

    if(_.isString(options) || _.isFunction(options)){
        options = { pattern: options };
    }
    
    if(!options){ options = {}; }

    var include = function (fileName, filePath){
        var shouldInclude = true;
        if(_.isFunction(options.pattern)){
            shouldInclude = options.pattern(fileName, filePath);
        }else if(_.isString(options.pattern)){
            shouldInclude = _.glob.matchFile(fileName, options.pattern);
        }
        return(shouldInclude);
    }
 
    var found = [];

    fs.walk(path, function onFile(fileName, filePath, next){
        if(include(fileName, filePath)){ found.push(filePath); }
        next();
    }, function onDir(dirName, dirPath, next){ 
        if(options.prune){ next(!options.prune(dirName, dirPath)); }
        else{ next(); }
    }, function(err){ 
        if(err){ callback(err); }
        else{ callback(null, found); }
    }); 
};

fs.find.sync = function(path, options){

    if(_.isString(options) || _.isFunction(options)){
        options = { pattern: options };
    }
    
    if(!options){ options = {}; }

    var include = function (fileName, filePath){
        var shouldInclude = true;
        if(_.isFunction(options.pattern)){
            shouldInclude = options.pattern(fileName, filePath);
        }else if(_.isString(options.pattern)){
            shouldInclude = _.glob.matchFile(fileName, options.pattern);
        }
        return(shouldInclude);
    }
 
    var found = [];

    fs.walk.sync(path, function onFile(fileName, filePath){
        if(include(fileName, filePath)){ found.push(filePath); }
    }, function onDir(dirName, dirPath){
        if(options.prune){ return(!options.prune(dirName, dirPath)); }
    }); 

    return(found);
};

fs.mkdir = function(path, mode, callback){
    
    if(_.isFunction(mode)){
        callback = mode;
        mode = null;
    }
    
    mode = mode || '755';
    
    path = _.path.slash(path);
    path = _.path.normalize(path);
    
    await{ fs.exists(path, _.plumb(defer(var exists), callback)); }

    if(exists){ return callback(); }

    var pathSplit = path.split("/");

    if(pathSplit.pop() === ""){ pathSplit.pop();}

    fs.mkdir(_.path.slash(pathSplit.join("/")), mode, function(err){
        if(err){ callback(err); }
        else{ nativeFs.mkdir(path, mode, callback); }
    });
};

fs.mkdir.sync = function(path, mode){
    mode = mode || '755';
    
    path = _.path.slash(path);
    path = _.path.normalize(path);

    if(!fs.exists.sync(path)){

        fs.mkdir.sync(_.path.slash(_.path.pop(path)), mode);
        
        nativeFs.mkdirSync(path, mode);
    }
};

fs.symlink = nativeFs.symlink;
fs.symlink.sync = nativeFs.symlinkSync;

fs.rm = nativeFs.unlink;
fs.rm.sync = nativeFs.unlinkSync;

fs.cpdir = function(from, to, callback){

    await{ _.fs.stat(from, defer(var err, stat)); }

    if(_.error.noent(err)){ return callback(err); }
    else if(!stat.isDirectory()){ return callback(_.error("ENOTDIR", err)); }
    else if(err){ return callback(_.error("CpdirError", err)); }
 
    await{ _.exec("cp -r " + from + " " + to, defer(var ecode, stderr, stdout)); }
    if(ecode){ return callback(_.error("CpdirError", "exit code: " + ecode + " stderr: " + stderr + " stdout: " + stdout)); }
        
    callback(null);
};

fs.rmdir = function(path, callback){
    path = _.path.slash(path);
        
    await{ fs.directories(path, _.plumb(defer(var folders), callback)); }

    _.each.async(folders, function(folder, index, next){
    
        await{ nativeFs.lstat(folder, _.plumb(defer(var stat), callback)); }

        if(stat.isSymbolicLink()){
            await{ nativeFs.unlink(folder, _.plumb(defer(), callback)); }
        }else{
            await{ fs.rmdir(folder, _.plumb(defer(), callback)); }
        }
        
        next();

    }, function(){

        await{ fs.files(path, _.plumb(defer(var files), callback), true); }

        _.each.async(files, function(file, index, next){
            await{ nativeFs.unlink(file, _.plumb(defer(), callback)); }
            next(); 
        }, function(){
            await{ nativeFs.rmdir(path, _.plumb(defer(), callback)); }
            callback();
        });
    });
};

fs.rmdir.sync = function(path){

    if(!fs.exists.sync(path)){ return; }
    
    var files = fs.readDir.sync(path);
    
    for(var i = 0; i < files.length; i++){
        var currentPath = _.path.join(path, files[i]);
        
        var stat = nativeFs.lstatSync(currentPath);

        if(stat.isSymbolicLink() || !stat.isDirectory()){
            nativeFs.unlinkSync(currentPath);
        }else{
            fs.rmdir.sync(currentPath);
        }
    }

    nativeFs.rmdirSync(path);
};
 
/*
fs.copyFileSync = function(srcFile, destFile){
    var BUF_LENGTH, buff, bytesRead, fdr, fdw, pos;
    BUF_LENGTH = 64 * 1024;
    buff = new Buffer(BUF_LENGTH);
    fdr = nativeFs.openSync(srcFile, 'r');
    fdw = nativeFs.openSync(destFile, 'w');
    bytesRead = 1;
    pos = 0;
    while (bytesRead > 0) {
        bytesRead = nativeFs.readSync(fdr, buff, 0, BUF_LENGTH, pos);
        nativeFs.writeSync(fdw, buff, 0, bytesRead);
        pos += bytesRead;
    }
    nativeFs.closeSync(fdr);
    return nativeFs.closeSync(fdw);
};

fs.getFolderContentInfo = function getFolderContentInfo(path, recursive, callback, filter, processInfo){
    if(typeof(recursive) === 'function'){
        callback = recursive;
        recursive = false;
    }

    if(!filter){ filter = function(){return(true);}; }
    if(!processInfo){ processInfo = function(){}; }
    
    var contents = [];
    
    await { nativeFs.readdir(path, defer(var err, files)); }
    if(err){ throw(err); }
    
    await {
        for(var i = 0; i < files.length; i++){
            (function(file, cb){
                if(filter(file)){
                    await { nativeFs.stat(_.path.join(path, file), defer(var err, stats));}
                    if(err){throw(err);}
                    var info = "";
                    if(recursive && stats.isDirectory() ){
                        await{ getFolderContentInfo(_.path.join(path, file), recursive, defer(var recursiveInfo), filter, processInfo); }
                        info = { FileName : file, FilePath : _.path.join(path, file), IsDirectory : stats.isDirectory(), Contents: recursiveInfo, MTime : stats.mtime, stats: stats};
                    }else{
                        info = { FileName : file, FilePath : _.path.join(path, file), IsDirectory : stats.isDirectory(), MTime : stats.mtime, stats: stats};
                    }
                    processInfo(info);
                    contents.push(info);
                }

                cb();
            })(files[i], defer());
        }
    }
    
    callback(contents);
};
*/

return(fs);

}

exports.fs = lib;
