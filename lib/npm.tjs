"use strict";

function lib(_){

var npm = {};

npm.install = function(packages, options, callback){

    if(_.isFunction(options)){
        callback = options;
        options = packages;
        packages = null;
    }

    var args = [];

    if(!options.link){ args.push("install"); }
    else{ options.push("link"); }

    if(options.verbose){ args.push("-verbose"); }
    if(options.root){ 
        var workingRoot = options.root;
        if(_.path.base(workingRoot) !== "node_modules"){
            workingRoot = _.path.join(workingRoot, "node_modules");
        }
        await{ _.fs.mkdir(workingRoot, _.plumb(defer(), callback)); }
        args.push("--prefix");
        args.push(options.root);
    } 

    if(!_.keys(packages).length){ return _.npm.exec(args, options, callback); }

    _.each.async(packages, function(packageVersion, packageName, next, done){
        var packageString =  packageVersion ? packageName + "@" + packageVersion : packageName;

        await{ _.npm.exec(_.concat(args, packageString), options, _.plumb(defer(), callback)); }

        // never gets here on error, plumb is like throw
        next();

    }, function(){ callback(null); });

};

npm.exec = function(args, options, callback){
    await{ _.exec("npm", args, defer(var code, stderr, stdout), options.shell); }
    if(code){ return callback(_.error("NpmError", "Error spawning npm, exit code: " + code, { exitCode: code, stderr: stderr, stdout: stdout })); }
    else{ return callback(null); }
};

return(npm);

}

exports.npm = lib;
